# Minesweeper
Ironbird Creations test task

# Description of the architecture
Game follows the UMVR architecture that we discussed, but I took some shortcuts:
1. Usually, I add a `bootstrap` scene responsible for replacing the `DontDestroyOnLoad` unity hack and providing shared resources wherever necessary (other scenes get loaded additively on top of `bootstrap`). Since it's usually a lot of boilerplate and I don't have it as part of "internal" toolset, here I went just for `SceneLoadMode.Simple`
2. For simplicity, `MainMenu` doesn't have a controller, everything is contained in `MainMenuView` - all it does is aggregate the UI from controls, push it to scriptable object and run a scene that will be actual gameplay. The "correct" way to do it would be to provide a model piece for `IApplicationSession`, bind it in `BootstrapScene`, fill in `MainMenuController` and consume in `GameController` (that share `Bootstrap` as a parent Zenject context) - but since this is just an example, I just mashed Main Menu logic into 49 glorious lines of View.
3. The game scene is much more "proper", in that it actually cares about separation of concerns. Game state is initialized by `GameSessionFactory`, tiles uncovering is handled by `UncoverFieldCommand`. UMVR takes care of providing changes to `GameSessionReactor` and `FieldReactor`; those, in turn, process and relay information to views. There's still a shortcut for the sake of simplicity - by the book, `GameSessionReactor` should not modify `FieldModel` (which it does by marking bomb tiles as failed when the game is lost). Theoretically, it'd be more proper to either:
   a. introduce the `IGameSession.LoseGame` method that will modify the fields, or
   b. observe the `IGameSession.IsGameLost` in `GameSessionController` and act on fields when it changes (but that, in turns, requires observing the `GameSessionRepository.Added` to capture `IGameSession` being created, so it's not trivial).
The reason for this "rule": in more complicated models, it's possible to introduce a circular dependency, where reactors trigger changes (another way to cause an infinite loop). It's a "flag in the code review", but not a rule that couldn't be sometimes broken to simplify the codebase.

# Potential caveats that I see
1. Right now, there's nothing holding the user from making the board with more bombs than fields except from a) UI settings and b) exception (thrown, but not handled). In original minesweeper, there were predetermined settings. Here, solution could be deciding on % of field being bombs instead of the actual number (but it's a design change, so _not really my call to make_).
2. I have used `SecondaryIndex` mechanism of `UMVR.Repository` to locate tiles spatially and simply put them in a `List`, instead of more "obvious" solution that would be a 2d array. I also use `Vector3Int` to hold coordinates of tiles. This is because the requirements stated that we may want to introduce other grid layouts in the future and it may be beneficial to have some more "storage" space for coordinates. For example, hexagonal tileset can be considered as a 3d system with a constraint on sum of coord elements (x + y + z = 0, so called `cube coordinates`), which will mean that a) 2d grid won't cut it anyway and b) additional Vector field can be useful.
There is a tradeoff though - `SecondaryIndex` causes one boxing allocation on each use. It's not a big issue in a small, not-real-time project, but something to look at if garbage allocations become an issue. We could, theoretically, have a convention for translating 2d coords to an int (e.x. `row * height + column`), but it would hurt the readability, so I optimised for reading the code.
3. If game gets more unique UI buttons, sometimes it's more convinient to have `Controller` as `MonoBehaviour`, so that UI elements can be provided to it directly. Depends on the case, not a case here.
4. I added the restart button since testing was unbearable. It reloads entire scene, which is a shortcut. If realoding becomes a concern, we'll need to start concerning ourselves with View cleanup. I don't like concerning myself with View cleanup, hence I call `Scene.Load` like there's no tomorrow.

# How could one further develop this project
1. Right now, there's no way to really win the game, except from not losing it for as long as possible. This could change.
2. In original Minesweeper game, there were some feaures that are missing here: flagging the fields as bombs, bombs counter, timer and cute little emoji closing it's eyes when the mouse was pressed - since the minesweeper is wrong only once. The flags are especially needed to make the game playable.
3. One feature that could be nice would be a way to mark multiple tiles and have the game uncover one that is NOT a bomb. This would solve for either a) uncovering the first tile that sometimes insta-ends the game and b) impossible to solve end game scenario, where player needs to take a chance of losing the entire playthrough.
